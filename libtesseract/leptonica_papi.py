# -*- coding: utf-8 -*-
"""
Created on Fri Jul 16 14:22:18 2021

@author: çš“
"""
from collections import namedtuple
from functools import wraps
import logging
from ctypes import (POINTER, c_void_p, c_char, c_char_p, cast, c_int, c_size_t,
                    byref)
from .datatype import (CommonAPI, c_int_p, c_uint_p, c_ubyte_p, c_float_p,
                       LP_c_char, get_point_value)
from .leptonica_capi import (LEPTONICA_API, LPPix, LPLPPix, LPLPPixa,
                             LPBox, LPLPBox, LPBoxa, LPPta, LPPixa, LPNuma)


Dimensions = namedtuple('Dimensions', ['width', 'height', 'depth'])


def check_return(func):
    '''0 if OK; 1 on error.'''
    @wraps(func)
    def wrapper(*args, **kwargs):
        rc, *result = func(*args, **kwargs)
        if rc:
            logging.error('Method %s run error.rc: %d', func.__name__, rc)
        if not result:
            return None
        return tuple(result)
    return wrapper


class LeptAPI(CommonAPI):

    @classmethod
    def get_text_value(cls, pdata: LP_c_char) -> bytes:
        assert isinstance(pdata, LP_c_char), "Arg pdata type isn't LP_c_char"
        data = cast(pdata, c_char_p)
        result = data.value
        cls.lept_free(data)
        return result

    @classmethod
    def get_version(cls) -> str:
        data = LEPTONICA_API.capi_get_leptonica_version()
        ret = cls.get_text_value(data)
        return cls.decode_utf8(ret)

    @classmethod
    def lept_stderr(cls, fmt: str, *args):
        '''
        Notes:
            (1) This is a replacement for fprintf(), to allow redirection
            of output.  All calls to fprintf(stderr, ...) are replaced
            with calls to lept_stderr(...).
            (2) The message size is limited to 2K bytes.
            (3) This utility was provided by jbarlow83.

        Parameters
        ----------
        fmt : str
            format string.
        *args : tuple[str]
            DESCRIPTION.

        Returns
        -------
        None.

        '''
        argv = [cls.encode(x) for x in args]
        LEPTONICA_API.capi_lept_stderr(cls.encode(fmt), *argv)

    @classmethod
    def lept_roundftoi(cls, fval: float) -> int:
        return LEPTONICA_API.capi_lept_roundftoi(fval)

    @classmethod
    def lept_isPrime(cls, n: int, pis_prime: c_int_p,
                     pfactor: c_uint_p) -> int:
        return LEPTONICA_API.capi_lept_isPrime(n, pis_prime, pfactor)

    @classmethod
    def lept_fopen(cls, filename: str, mode: str) -> c_void_p:
        '''
        Notes:
            (1) This must be used by any application that passes
            a file handle to a leptonica Windows DLL.

        Parameters
        ----------
        filename : str
            filename.
        mode : str
            same as for fopen(); e.g., "rb".

        Returns
        -------
        c_void_p
            stream or NULL on error.

        '''
        return LEPTONICA_API.capi_lept_fopen(cls.encode(filename),
                                             cls.encode(mode))

    @classmethod
    def lept_fclose(cls, fp: c_void_p) -> int:
        '''
        Notes:
            (1) This should be used by any application that accepts
            a file handle generated by a leptonica Windows DLL.

        Parameters
        ----------
        fp : c_void_p
            file stream.

        Returns
        -------
        int
            0 if OK, 1 on error.

        '''
        return LEPTONICA_API.capi_lept_fclose(fp)

    @classmethod
    def lept_calloc(cls, nmemb: int, size: int) -> c_void_p:
        '''
        Notes:
            (1) For safety with windows DLLs, this can be used in conjunction
            with lept_free() to avoid C-runtime boundary problems.
            Just use these two functions throughout your application.

        Parameters
        ----------
        nmemb : int
            number of members.
        size : int
            of each member.

        Returns
        -------
        c_void_p
            void ptr, or NULL on error.

        '''
        return LEPTONICA_API.capi_lept_calloc(nmemb, size)

    @classmethod
    def lept_free(cls, ptr: c_void_p):
        '''
        Notes:
            (1) This should be used by any application that accepts
            heap data allocated by a leptonica Windows DLL.

        Parameters
        ----------
        ptr : c_void_p
            ptr.

        '''
        LEPTONICA_API.capi_lept_free(ptr)

    @classmethod
    def lept_mkdir(cls, subdir: str) -> int:
        '''
        Notes:
            (1) %subdir is a partial path that can consist of one or more
            directories.
            (2) This makes any subdirectories of /tmp that are required.
            (3) The root temp directory is:
            /tmp    (unix)  [default]
            [Temp]  (windows)

        Parameters
        ----------
        subdir : str
            of /tmp or its equivalent on Windows.

        Returns
        -------
        int
            0 on success, non-zero on failure.

        '''
        return LEPTONICA_API.capi_lept_mkdir(cls.encode(subdir))

    @classmethod
    def lept_rmdir(cls, subdir: str) -> int:
        '''
        Notes:
            (1) %subdir is a partial path that can consist of one or more
            directories.
            (2) This removes all files from the specified subdirectory of
            the root temp directory:
            /tmp    (unix)
            [Temp]  (windows)
            and then removes the subdirectory.
            (3) The combination
            lept_rmdir(subdir);
            lept_mkdir(subdir);
            is guaranteed to give you an empty subdirectory.

        Parameters
        ----------
        subdir : str
            of /tmp or its equivalent on Windows.

        Returns
        -------
        int
            0 on success, non-zero on failure.

        '''
        return LEPTONICA_API.capi_lept_rmdir(cls.encode(subdir))

    @classmethod
    def lept_direxists(cls, dir_: str, pexists: c_int_p) -> bool:
        '''
        Notes:
            (1) Always use unix pathname separators.
            (2) By calling genPathname(), if the pathname begins with "/tmp"
            this does an automatic directory translation on windows
            to a path in the windows [Temp] directory:
            "/tmp"  ==>  [Temp] (windows)

        Parameters
        ----------
        dir_ : str
            dir.

        Returns
        -------
        bool
            True if it exists; False otherwise.

        '''
        pexists = c_int()
        LEPTONICA_API.capi_lept_direxists(cls.encode(dir_), byref(pexists))
        return bool(pexists.value)

    @classmethod
    def lept_rm_match(cls, subdir: str = None, substr: str = None) -> int:
        '''
        Notes:
            (1) This removes the matched files in /tmp or a subdirectory of
            /tmp. Use NULL for %subdir if the files are in /tmp.
            (2) If %substr == NULL, this removes all files in the directory.
            If %substr == "" (empty), this removes no files.
            If both %subdir == NULL and %substr == NULL, this removes
            all files in /tmp.
            (3) Use unix pathname separators.
            (4) By calling genPathname(), if the pathname begins with "/tmp"
            this does an automatic directory translation on windows
            to a path in the windows [Temp] directory:
            "/tmp"  ==>  [Temp] (windows)
            (5) Error conditions:
            returns -1 if the directory is not found
            returns the number of files (> 0) that it was unable to remove.

        Parameters
        ----------
        subdir : str, optional
            if None, the removed files are in /tmp. The default is None.
        substr : str, optional
            pattern to match in filename. The default is None.

        Returns
        -------
        int
            on success, non-zero on failure.

        '''
        return LEPTONICA_API.capi_lept_rm_match(cls.encode(subdir),
                                                cls.encode(substr))

    @classmethod
    def lept_rm(cls, subdir: str, tail: str) -> int:
        '''
        Notes:
            (1) By calling genPathname(), this does an automatic directory
            translation on windows to a path in the windows [Temp] directory:
            "/tmp/..."  ==>  [Temp]/... (windows)

        Parameters
        ----------
        subdir : str, optional
            subdir of '/tmp'; can be None.
        tail : str
            filename without the directory.

        Returns
        -------
        int
            0 on success, non-zero on failure.

        '''
        return LEPTONICA_API.capi_lept_rm(cls.encode(subdir), cls.encode(tail))

    @classmethod
    def lept_rmfile(cls, filepath: str) -> int:
        '''
        Notes:
            (1) This removes the named file.
            (2) Use unix pathname separators.
            (3) There is no name translation.
            (4) Unlike the other lept_* functions in this section, this can
            remove any file -- it is not restricted to files that are in /tmp
            or a subdirectory of it.

        Parameters
        ----------
        filepath : str
            full path to file including the directory.

        Returns
        -------
        int
            0 on success, non-zero on failure.

        '''
        return LEPTONICA_API.capi_lept_rmfile(cls.encode(filepath))

    @classmethod
    @check_return
    def lept_mv(cls, srcfile: str, newdir: str, newtail: str) -> int:
        '''
        Notes:
            (1) This moves %srcfile to /tmp or to a subdirectory of /tmp.
            (2) %srcfile can either be a full path or relative to the
            current directory.
            (3) %newdir can either specify an existing subdirectory of /tmp
            or can be NULL.  In the latter case, the file will be written
            into /tmp.
            (4) %newtail can either specify a filename tail or, if NULL,
            the filename is taken from src-tail, the tail of %srcfile.
            (5) For debugging, the computed newpath can be returned.  It must
            be freed by the caller.
            (6) Reminders:
            (a) specify files using unix pathnames
            (b) for windows, translates
            /tmp  ==>  [Temp]
            where [Temp] is the windows temp directory
            (7) Examples:
            newdir = NULL,    newtail = NULL    ==> /tmp/src-tail
            newdir = NULL,    newtail = abc     ==> /tmp/abc
            newdir = def/ghi, newtail = NULL    ==> /tmp/def/ghi/src-tail
            newdir = def/ghi, newtail = abc     ==> /tmp/def/ghi/abc

        Parameters
        ----------
        srcfile : str
            can be None.
        newdir : str, optional
            can be None. The default is None.
        newtail : str, optional
            can be None. The default is None.

        Returns
        -------
        str
            of actual path; can be None.

        '''
        pnewpath = POINTER(c_char_p)()
        rc = LEPTONICA_API.capi_lept_mv(cls.encode(srcfile),
                                        cls.encode(newdir),
                                        cls.encode(newtail), pnewpath)
        newpath = get_point_value(pnewpath)
        cls.lept_free(pnewpath.contents)
        return rc, newpath

    @classmethod
    @check_return
    def lept_cp(cls, srcfile: str, newdir: str = None,
                newtail: str = None) -> str:
        '''
        Notes:
        (1) This copies %srcfile to /tmp or to a subdirectory of /tmp.
        (2) %srcfile can either be a full path or relative to the
        current directory.
        (3) %newdir can either specify an existing subdirectory of /tmp,
        or can be NULL.  In the latter case, the file will be written
        into /tmp.
        (4) %newtail can either specify a filename tail or, if NULL,
        the filename is taken from src-tail, the tail of %srcfile.
        (5) For debugging, the computed newpath can be returned.  It must
        be freed by the caller.
        (6) Reminders:
        (a) specify files using unix pathnames
        (b) for windows, translates
        /tmp  ==>  [Temp]
        where [Temp] is the windows temp directory
        (7) Examples:
        newdir = NULL,    newtail = NULL    ==> /tmp/src-tail
        newdir = NULL,    newtail = abc     ==> /tmp/abc
        newdir = def/ghi, newtail = NULL    ==> /tmp/def/ghi/src-tail
        newdir = def/ghi, newtail = abc     ==> /tmp/def/ghi/abc

        Parameters
        ----------
        srcfile : str
            can be None.
        newdir : str, optional
            can be None. The default is None.
        newtail : str, optional
            can be None. The default is None.

        Returns
        -------
        str
            of actual path.

        '''
        pnewpath = POINTER(c_char_p)()
        rc = LEPTONICA_API.capi_lept_cp(cls.encode(srcfile),
                                        cls.encode(newdir),
                                        cls.encode(newtail), pnewpath)
        newpath = get_point_value(pnewpath)
        cls.lept_free(pnewpath.contents)
        return rc, newpath


class PixAPI(CommonAPI):

    @classmethod
    @check_return
    def pix_otsu_adaptive_threshold(cls, pixs: LPPix, sx: int, sy: int,
                                    smoothx: int, smoothy: int,
                                    scorefract: float) -> tuple[LPPix, LPPix]:
        pppixth = LPLPPix()
        pppixd = LPLPPix()
        rc = LEPTONICA_API.capi_pix_otsu_adaptive_threshold(pixs, sx, sy,
                                                            smoothx, smoothy,
                                                            scorefract,
                                                            pppixth, pppixd)
        return rc, get_point_value(pppixth), get_point_value(pppixd)

    @classmethod
    @check_return
    def pix_sauvola_binarize_tiled(cls, pixs: LPPix,
                                   whsize: int, factor: float,
                                   nx: int, ny: int) -> tuple[LPPix, LPPix]:
        pppixth = LPLPPix()
        pppixd = LPLPPix()
        rc = LEPTONICA_API.capi_pix_sauvola_binarize_tiled(pixs, whsize,
                                                           factor, nx, ny,
                                                           pppixth, pppixd)
        return rc, get_point_value(pppixth), get_point_value(pppixd)

    @classmethod
    def pix_reduce_rank_binary_cascade(cls, pixs: LPPix,
                                       level1: int, level2: int,
                                       level3: int, level4: int) -> LPPix:
        return LEPTONICA_API.capi_pix_reduce_rank_binary_cascade(
            pixs, level1, level2, level3, level4)

    @classmethod
    def pix_conn_comp(
            cls,
            pixs: LPPix,
            ppixa: LPLPPixa,
            connectivity: int) -> LPBoxa:
        return LEPTONICA_API.capi_pix_conn_comp(pixs, ppixa, connectivity)

    @classmethod
    @check_return
    def pix_count_conn_comp(cls, pixs: LPPix, connectivity: int) -> int:
        pcount = c_int()
        rc = LEPTONICA_API.capi_pix_count_conn_comp(pixs, connectivity,
                                                    byref(pcount))
        return rc, pcount.value

    @classmethod
    def pix_blockconv(cls, pix: LPPix, wc: int, hc: int) -> LPPix:
        return LEPTONICA_API.capi_pix_blockconv(pix, wc, hc)

    @classmethod
    def pix_add_gaussian_noise(cls, pixs: LPPix, stdev: float) -> LPPix:
        return LEPTONICA_API.capi_pix_add_gaussian_noise(pixs, stdev)

    @classmethod
    def pix_render_box_arb(
            cls,
            pix: LPPix,
            box: LPBox,
            width: int,
            rval: int,
            gval: int,
            bval: int) -> int:
        return LEPTONICA_API.capi_pix_render_box_arb(
            pix, box, width, rval, gval, bval)

    @classmethod
    def pix_render_polyline(
            cls,
            pix: LPPix,
            ptas: LPPta,
            width: int,
            op: int,
            closeflag: int) -> int:
        return LEPTONICA_API.capi_pix_render_polyline(
            pix, ptas, width, op, closeflag)

    @classmethod
    def pix_render_polyline_arb(
            cls,
            pix: LPPix,
            ptas: LPPta,
            width: int,
            rval: int,
            gval: int,
            bval: int,
            closeflag: int) -> int:
        return LEPTONICA_API.capi_pix_render_polyline_arb(
            pix, ptas, width, rval, gval, bval, closeflag)

    @classmethod
    def pix_erode_gray(cls, pixs: LPPix, hsize: int, vsize: int) -> LPPix:
        return LEPTONICA_API.capi_pix_erode_gray(pixs, hsize, vsize)

    @classmethod
    def pix_threshold_to_binary(cls, pixs: LPPix, thresh: int) -> LPPix:
        return LEPTONICA_API.capi_pix_threshold_to_binary(pixs, thresh)

    @classmethod
    def pix_write_jpeg(cls, filename: str, pix: LPPix,
                       quality: int, progressive: int) -> int:
        return LEPTONICA_API.capi_pix_write_jpeg(
            cls.encode(filename), pix, quality, progressive)

    @classmethod
    def pix_dilate_brick(
            cls,
            pixd: LPPix,
            pixs: LPPix,
            hsize: int,
            vsize: int) -> LPPix:
        return LEPTONICA_API.capi_pix_dilate_brick(pixd, pixs, hsize, vsize)

    @classmethod
    def pix_erode_brick(
            cls,
            pixd: LPPix,
            pixs: LPPix,
            hsize: int,
            vsize: int) -> LPPix:
        return LEPTONICA_API.capi_pix_erode_brick(pixd, pixs, hsize, vsize)

    @classmethod
    def pix_open_brick(
            cls,
            pixd: LPPix,
            pixs: LPPix,
            hsize: int,
            vsize: int) -> LPPix:
        return LEPTONICA_API.capi_pix_open_brick(pixd, pixs, hsize, vsize)

    @classmethod
    def pix_close_brick(
            cls,
            pixd: LPPix,
            pixs: LPPix,
            hsize: int,
            vsize: int) -> LPPix:
        return LEPTONICA_API.capi_pix_close_brick(pixd, pixs, hsize, vsize)

    @classmethod
    def pix_gen_halftone_mask(
            cls,
            pixs: LPPix,
            ppixtext: LPLPPix,
            phtfound: c_int_p,
            debug: int) -> LPPix:
        return LEPTONICA_API.capi_pix_gen_halftone_mask(
            pixs, ppixtext, phtfound, debug)

    @classmethod
    def pix_generate_halftone_mask(
            cls,
            pixs: LPPix,
            ppixtext: LPLPPix,
            phtfound: c_int_p,
            pixadb: LPPixa) -> LPPix:
        return LEPTONICA_API.capi_pix_generate_halftone_mask(
            pixs, ppixtext, phtfound, pixadb)

    @classmethod
    def pix_create(cls, width: int, height: int, depth: int) -> LPPix:
        return LEPTONICA_API.capi_pix_create(width, height, depth)

    @classmethod
    def pix_create_template(cls, pixs: LPPix) -> LPPix:
        return LEPTONICA_API.capi_pix_create_template(pixs)

    @classmethod
    def pix_create_header(cls, width: int, height: int, depth: int) -> LPPix:
        return LEPTONICA_API.capi_pix_create_header(width, height, depth)

    @classmethod
    def pix_clone(cls, pixs: LPPix) -> LPPix:
        return LEPTONICA_API.capi_pix_clone(pixs)

    @classmethod
    def pix_destroy(cls, ppix: LPLPPix):
        LEPTONICA_API.capi_pix_destroy(ppix)

    @classmethod
    def pix_copy(cls, pixd: LPPix, pixs: LPPix) -> LPPix:
        return LEPTONICA_API.capi_pix_copy(pixd, pixs)

    @classmethod
    def pix_get_width(cls, pix: LPPix) -> int:
        return LEPTONICA_API.capi_pix_get_width(pix)

    @classmethod
    def pix_get_height(cls, pix: LPPix) -> int:
        return LEPTONICA_API.capi_pix_get_height(pix)

    @classmethod
    def pix_get_depth(cls, pix: LPPix) -> int:
        return LEPTONICA_API.capi_pix_get_depth(pix)

    @classmethod
    def pix_get_dimensions(cls, pix: LPPix) -> tuple[int, int, int]:
        pw = c_int()
        ph = c_int()
        pd = c_int()
        ret = LEPTONICA_API.capi_pix_get_dimensions(pix,
                                                    byref(pw),
                                                    byref(ph),
                                                    byref(pd))
        if ret:
            print('pix not defined')
        return Dimensions(pw.value, ph.value, pd.value)

    @classmethod
    def pix_get_spp(cls, pix: LPPix) -> int:
        return LEPTONICA_API.capi_pix_get_spp(pix)

    @classmethod
    def pix_set_spp(cls, pix: LPPix, spp: int) -> int:
        return LEPTONICA_API.capi_pix_set_spp(pix, spp)

    @classmethod
    def pix_get_wpl(cls, pix: LPPix) -> int:
        return LEPTONICA_API.capi_pix_get_wpl(pix)

    @classmethod
    def pix_get_x_res(cls, pix: LPPix) -> int:
        return LEPTONICA_API.capi_pix_get_x_res(pix)

    @classmethod
    def pix_set_x_res(cls, pix: LPPix, res: int) -> int:
        return LEPTONICA_API.capi_pix_set_x_res(pix, res)

    @classmethod
    def pix_get_y_res(cls, pix: LPPix) -> int:
        return LEPTONICA_API.capi_pix_get_y_res(pix)

    @classmethod
    def pix_set_y_res(cls, pix: LPPix, res: int) -> int:
        return LEPTONICA_API.capi_pix_set_y_res(pix, res)

    @classmethod
    def pix_get_input_format(cls, pix: LPPix) -> int:
        return LEPTONICA_API.capi_pix_get_input_format(pix)

    @classmethod
    def pix_set_text(cls, pix: LPPix, textstring: str) -> int:
        return LEPTONICA_API.capi_pix_set_text(pix, cls.encode(textstring))

    @classmethod
    def pix_get_data(cls, pix: LPPix) -> c_uint_p:
        return LEPTONICA_API.capi_pix_get_data(pix)

    @classmethod
    def pix_set_data(cls, pix: LPPix, data: c_uint_p) -> int:
        return LEPTONICA_API.capi_pix_set_data(pix, data)

    @classmethod
    def pix_get_pixel(cls, pix: LPPix, x: int, y: int, pval: c_uint_p) -> int:
        return LEPTONICA_API.capi_pix_get_pixel(pix, x, y, pval)

    @classmethod
    def pix_set_pixel(cls, pix: LPPix, x: int, y: int, val: int) -> int:
        return LEPTONICA_API.capi_pix_set_pixel(pix, x, y, val)

    @classmethod
    def pix_set_all(cls, pix: LPPix) -> int:
        return LEPTONICA_API.capi_pix_set_all(pix)

    @classmethod
    def pix_set_all_arbitrary(cls, pix: LPPix, val: int) -> int:
        return LEPTONICA_API.capi_pix_set_all_arbitrary(pix, val)

    @classmethod
    def pix_clear_in_rect(cls, pix: LPPix, box: LPBox) -> int:
        return LEPTONICA_API.capi_pix_clear_in_rect(pix, box)

    @classmethod
    def pix_set_in_rect(cls, pix: LPPix, box: LPBox) -> int:
        return LEPTONICA_API.capi_pix_set_in_rect(pix, box)

    @classmethod
    def pix_set_or_clear_border(
            cls,
            pixs: LPPix,
            left: int,
            right: int,
            top: int,
            bot: int,
            op: int) -> int:
        return LEPTONICA_API.capi_pix_set_or_clear_border(
            pixs, left, right, top, bot, op)

    @classmethod
    def pix_add_border(cls, pixs: LPPix, npix: int, val: int) -> LPPix:
        return LEPTONICA_API.capi_pix_add_border(pixs, npix, val)

    @classmethod
    def pix_set_masked(cls, pixd: LPPix, pixm: LPPix, val: int) -> int:
        return LEPTONICA_API.capi_pix_set_masked(pixd, pixm, val)

    @classmethod
    def pix_invert(cls, pixd: LPPix, pixs: LPPix) -> LPPix:
        return LEPTONICA_API.capi_pix_invert(pixd, pixs)

    @classmethod
    def pix_or(cls, pixd: LPPix, pixs1: LPPix, pixs2: LPPix) -> LPPix:
        return LEPTONICA_API.capi_pix_or(pixd, pixs1, pixs2)

    @classmethod
    def pix_and(cls, pixd: LPPix, pixs1: LPPix, pixs2: LPPix) -> LPPix:
        return LEPTONICA_API.capi_pix_and(pixd, pixs1, pixs2)

    @classmethod
    def pix_xor(cls, pixd: LPPix, pixs1: LPPix, pixs2: LPPix) -> LPPix:
        return LEPTONICA_API.capi_pix_xor(pixd, pixs1, pixs2)

    @classmethod
    def pix_subtract(cls, pixd: LPPix, pixs1: LPPix, pixs2: LPPix) -> LPPix:
        return LEPTONICA_API.capi_pix_subtract(pixd, pixs1, pixs2)

    @classmethod
    @check_return
    def pix_zero(cls, pix: LPPix, pempty: c_int_p) -> int:
        pempty = c_int()
        rc = LEPTONICA_API.capi_pix_zero(pix, byref(pempty))
        return rc, pempty.value

    @classmethod
    def pix_foreground_fraction(cls, pix: LPPix, pfract: c_float_p) -> int:
        return LEPTONICA_API.capi_pix_foreground_fraction(pix, pfract)

    @classmethod
    def pix_count_pixels(
            cls,
            pixs: LPPix,
            pcount: c_int_p,
            tab8: c_int_p) -> int:
        return LEPTONICA_API.capi_pix_count_pixels(pixs, pcount, tab8)

    @classmethod
    def pix_count_pixels_by_row(cls, pix: LPPix, tab8: c_int_p) -> LPNuma:
        return LEPTONICA_API.capi_pix_count_pixels_by_row(pix, tab8)

    @classmethod
    def pix_count_pixels_in_row(
            cls,
            pix: LPPix,
            row: int,
            pcount: c_int_p,
            tab8: c_int_p) -> int:
        return LEPTONICA_API.capi_pix_count_pixels_in_row(
            pix, row, pcount, tab8)

    @classmethod
    def pix_clip_rectangle(
            cls,
            pixs: LPPix,
            box: LPBox,
            pboxc: LPLPBox) -> LPPix:
        return LEPTONICA_API.capi_pix_clip_rectangle(pixs, box, pboxc)

    @classmethod
    def pix_clip_box_to_foreground(
            cls,
            pixs: LPPix,
            boxs: LPBox,
            ppixd: LPLPPix,
            pboxd: LPLPBox) -> int:
        return LEPTONICA_API.capi_pix_clip_box_to_foreground(
            pixs, boxs, ppixd, pboxd)

    @classmethod
    def pix_convert_to8(cls, pixs: LPPix, cmapflag: int) -> LPPix:
        return LEPTONICA_API.capi_pix_convert_to8(pixs, cmapflag)

    @classmethod
    def pix_convert_to32(cls, pixs: LPPix) -> LPPix:
        return LEPTONICA_API.capi_pix_convert_to32(pixs)

    @classmethod
    def pix_convert24to32(cls, pixs: LPPix) -> LPPix:
        return LEPTONICA_API.capi_pix_convert24to32(pixs)

    @classmethod
    def pix_remove_alpha(cls, pixs: LPPix) -> LPPix:
        return LEPTONICA_API.capi_pix_remove_alpha(pixs)

    @classmethod
    def pix_projective(cls, pixs: LPPix, vc: c_float_p, incolor: int) -> LPPix:
        return LEPTONICA_API.capi_pix_projective(pixs, vc, incolor)

    @classmethod
    def pix_read(cls, filename: str) -> LPPix:
        return LEPTONICA_API.capi_pix_read(cls.encode(filename))

    @classmethod
    def pix_read_mem(cls, data: c_ubyte_p, size: int) -> LPPix:
        return LEPTONICA_API.capi_pix_read_mem(data, size)

    @classmethod
    def pix_rasterop(
            cls,
            pixd: LPPix,
            dx: int,
            dy: int,
            dw: int,
            dh: int,
            op: int,
            pixs: LPPix,
            sx: int,
            sy: int) -> int:
        return LEPTONICA_API.capi_pix_rasterop(
            pixd, dx, dy, dw, dh, op, pixs, sx, sy)

    @classmethod
    def pix_rotate(
            cls,
            pixs: LPPix,
            angle: float,
            type: int,
            incolor: int,
            width: int,
            height: int) -> LPPix:
        return LEPTONICA_API.capi_pix_rotate(
            pixs, angle, type, incolor, width, height)

    @classmethod
    def pix_rotate_orth(cls, pixs: LPPix, quads: int) -> LPPix:
        return LEPTONICA_API.capi_pix_rotate_orth(pixs, quads)

    @classmethod
    def pix_rotate180(cls, pixd: LPPix, pixs: LPPix) -> LPPix:
        return LEPTONICA_API.capi_pix_rotate180(pixd, pixs)

    @classmethod
    def pix_scale(cls, pixs: LPPix, scalex: float, scaley: float) -> LPPix:
        return LEPTONICA_API.capi_pix_scale(pixs, scalex, scaley)

    @classmethod
    def pix_scale_to_size(cls, pixs: LPPix, wd: int, hd: int) -> LPPix:
        return LEPTONICA_API.capi_pix_scale_to_size(pixs, wd, hd)

    @classmethod
    def pix_expand_replicate(cls, pixs: LPPix, factor: int) -> LPPix:
        return LEPTONICA_API.capi_pix_expand_replicate(pixs, factor)

    @classmethod
    def pix_seedfill_binary(
            cls,
            pixd: LPPix,
            pixs: LPPix,
            pixm: LPPix,
            connectivity: int) -> LPPix:
        return LEPTONICA_API.capi_pix_seedfill_binary(
            pixd, pixs, pixm, connectivity)

    @classmethod
    def pix_distance_function(
            cls,
            pixs: LPPix,
            connectivity: int,
            outdepth: int,
            boundcond: int) -> LPPix:
        return LEPTONICA_API.capi_pix_distance_function(
            pixs, connectivity, outdepth, boundcond)

    @classmethod
    def pix_read_tiff(cls, filename: str, n: int) -> LPPix:
        return LEPTONICA_API.capi_pix_read_tiff(cls.encode(filename), n)

    @classmethod
    def pix_write_tiff(cls, filename: str, pix: LPPix, comptype: int,
                       modestr: str) -> int:
        return LEPTONICA_API.capi_pix_write_tiff(cls.encode(filename),
                                                 pix, comptype,
                                                 cls.encode(filename))

    @classmethod
    def pix_read_from_multipage_tiff(cls, fname: str,
                                     offset: int) -> tuple[LPPix, int]:
        poffset = c_size_t(offset)
        ret = LEPTONICA_API.capi_pix_read_from_multipage_tiff(
            cls.encode(fname), byref(poffset))
        return ret, poffset.value

    @classmethod
    def pix_read_mem_tiff(cls, cdata: bytes, n: int) -> LPPix:
        data = cast(cdata, c_ubyte_p)
        size = len(cdata)
        return LEPTONICA_API.capi_pix_read_mem_tiff(data, size, n)

    @classmethod
    def pix_read_mem_from_multipage_tiff(cls, cdata: bytes,
                                         offset: int) -> LPPix:
        data = cast(cdata, c_ubyte_p)
        size = len(cdata)
        poffset = c_size_t(offset)
        ret = LEPTONICA_API.capi_pix_read_mem_from_multipage_tiff(
            data, size, byref(poffset))
        return ret, poffset.value

    @classmethod
    def pix_write(cls, fname: str, pix: LPPix, format: int) -> int:
        return LEPTONICA_API.capi_pix_write(cls.encode(fname), pix, format)

    @classmethod
    @check_return
    def pix_write_mem(cls, pix: LPPix, format: int) -> int:
        ppdata = POINTER(c_ubyte_p)()
        psize = c_size_t()
        rc = LEPTONICA_API.capi_pix_write_mem(ppdata, byref(psize), pix,
                                              format)
        pdata = ppdata.contents
        size = psize.value
        return rc, bytes(pdata[:size])
